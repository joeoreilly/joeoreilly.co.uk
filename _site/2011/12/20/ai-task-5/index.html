<!doctype HTML>
<html>

<head>
	<title>Joseph O'Reilly - AI - Task Sheet 5</title>
	
	<link rel="stylesheet" type="text/css" href="/css/core.css">
	<link rel="stylesheet" type="text/css" href="/css/styles/solarized_light.css">

	<script type="text/javascript" src="/js/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	
	<!-- <script type="text/javascript" src="//use.typekit.net/nyb3qqd.js"></script> -->
</head>

<body>
	
	<header>
		
		<h1><a href="/">Joe O'Reilly</a></h1>
		
		<hr/>
<nav>
	<a href="/">home</a> <a href="/blog/">blog</a> <a href="/work/">work</a> <a href="/cv/">cv</a>
</nav>
<hr/>
		
	</header>

<article>
        <header>
			<h2>AI - Task Sheet 5</h1>
				
			<p class="date">
				<span class="date">20 Dec 2011</span>
				
					
				
			</p>

        </header>

        <div class="entry"><h3>5.1</h3>

<h4>Basic Obstacle Detection &amp; Avoidance With Touch</h4>

<h5>Bumper Attached and Ready</h5>

<p><img src="/media/images/bumper.jpg" alt="" /></p>

<p>Below is the algorithm that moves the robot forwards until its bump sensor is activated when it stops, backs up and turns.</p>

<p>Move and Bump</p>

<p><img src="/media/images/bump-turn.png" alt="" /></p>

<p>Here is the back turn behaviour, stop motors, move back turn on the spot towards the right hand side.</p>

<p>Back Turn</p>

<p><img src="/media/images/back-turn.png" alt="" /></p>

<h3>5.1a</h3>

<h4>Touch-Based Obstacle Avoidance as a way of Traversing a Simple Maze</h4>

<p>We used the algorithm described in section 5.1 and attempted to navigate a maze. There were a handfull of errors:</p>

<ul>
<li>Motor noise was compounded as the robot turned and made no attempt to correct itself.</li>
<li>There is a high probability that the robot could become stuck in an infinite loop because he only turns one way (see diagram below).</li>
<li>The only solveable mazes would need to contain no loops, and this is assuming that the robot will stay dead straight.</li>
</ul>


<p><img src="/media/images/diagram-loop-3.png" alt="" /></p>

<h3>5.2</h3>

<h4>Basic Obstacle Detection &amp; Avoidance With Ultrasound</h4>

<p><img src="/media/images/forward-ultrasonic.jpg" alt="" /></p>

<p>First we moved one of the robots ultrasonic sensors to face forwards(right) then we built a program to control the robot's movement.</p>

<p>Here you can see we have a loop containing a forwards motor control block then an if based on the forward facing sensor. When the robot got too close it would turn, as it didn't bump we didn't require any reversing.</p>

<p><img src="/media/images/forward-ultrasonic-block.png" alt="" /></p>

<p>Here is the settings used in the ultrasonic sensor if block.</p>

<p><img src="/media/images/ultrasonic-nav-det.png" alt="" /></p>

<h3>5.2a</h3>

<h4>Ultrasound-Based Obstacle Avoidance as a way of Traversing a Simple Maze</h4>

<p>When we used this code to attemp to solve a maze it had some improvements:</p>

<ul>
<li>There were no collsions, so the robot's navigation was more reliable however not perfect.</li>
<li>It handled narrow corridors better because it turns earlier</li>
</ul>


<p>However it didn't solve some problems that existed in the first attempt:</p>

<ul>
<li>It made no attempt to correct itself.</li>
<li>The robot could become stuck in an infinite loop because he only turns one way</li>
<li>The robot can only solve simple mazes</li>
</ul>


<h3>5.3</h3>

<h4>Wall-Following With Obstacle-Avoidance With Touch</h4>

<p>We used the reactive control algorithm fro Task 4.3 including its bump behaviour. This worked very well and will probably be the algorith we used in the maze. To make the robot follow a wall on its other side we had to move the utlrasonic sensor to that side and change the program to turn the right way.</p>

<p>For the robot to chose between two walls a master program would have to be built that either executed wall following on the left or right depending on it's sensor readings.</p>

<h3>5.4</h3>

<h4>Wall-Following With Obstacle-Avoidance With Ultrasound</h4>

<p>We moved the to the front and changed the code to turn when it got too close (&lt;10cm) to a wall and then turn. The Robot was a little unpredicable when sensing ahead and movign, to compensate we slowed it down.</p>
</div>

</article>

<br/>

<footer>

<p>&copy; 2014 Joseph O'Reilly - All work under <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/">CC BY-NC-ND 3.0</a> - <a href="http://www.github.com/joeoreilly">GitHub</a> - <a href="http://careers.stackoverflow.com/joeoreilly ">Careers 2.0</a> - <a href="http://twitter.com/joeoreilly">Twitter</a> - <script type="text/javascript">
//<![CDATA[
<!--
var x="function f(x){var i,o=\"\",ol=x.length,l=ol;while(x.charCodeAt(l/13)!" +
"=111){try{x+=x;l+=l;}catch(e){}}for(i=l-1;i>=0;i--){o+=x.charAt(i);}return " +
"o.substr(0,ol);}f(\")02,\\\"-%/:0/q 2aejgL6%Z|hokdRY2\\\\\\\\320\\\\n\\\\43" +
"0\\\\310\\\\030\\\\<U000\\\\020\\\\320\\\\500\\\\630\\\\000\\\\-O0V710\\\\5" +
"00\\\\430\\\\610\\\\220\\\\EF?t\\\\420\\\\N0=s%760=%90;9220\\\\%3.:##(p&<+/" +
"$)a630\\\\|&ZLU430\\\\F230\\\\700\\\\410\\\\MNDTvlj2ot|ubuzp\\\"(f};o nrute" +
"r};))++y(^)i(tAedoCrahc.x(edoCrahCmorf.gnirtS=+o;721=%y;i=+y)02==i(fi{)++i;" +
"l<i;0=i(rof;htgnel.x=l,\\\"\\\"=o,i rav{)y,x(f noitcnuf\")"                  ;
while(x=eval(x));
//-->
//]]>
</script>

</p></footer>

</body>

</html>

<script>
	hljs.initHighlightingOnLoad();	
</script>
